{
  "version": 3,
  "sources": ["webpack:///webpack/universalModuleDefinition", "webpack:///webpack/bootstrap%2050bc65c99ab5cf08ee3e", "webpack:///src/assign.js", "webpack:///src/euler/spring.js", "webpack:///src/euler/index.js", "webpack:///src/euler/body.js", "webpack:///src/euler/defaults.js", "webpack:///src/euler/drag.js", "webpack:///src/euler/integrate.js", "webpack:///src/euler/quadtree/index.js", "webpack:///src/euler/quadtree/insertStack.js", "webpack:///src/euler/quadtree/node.js", "webpack:///src/euler/tick.js", "webpack:///src/index.js", "webpack:///src/layout/defaults.js", "webpack:///src/layout/index.js", "webpack:///src/layout/make-bb.js", "webpack:///src/layout/position.js", "webpack:///src/layout/tick.js"],
  "sourcesContent": ["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"cytoscapeEuler\"] = factory();\n\telse\n\t\troot[\"cytoscapeEuler\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition", " \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 11);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 50bc65c99ab5cf08ee3e", "module.exports = Object.assign != null ? Object.assign.bind( Object ) : function( tgt, ...srcs ){\n  srcs.forEach( src => {\n    Object.keys( src ).forEach( k => tgt[k] = src[k] );\n  } );\n\n  return tgt;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/assign.js", "const assign = require('../assign');\n\nconst defaults = Object.freeze({\n  source: null,\n  target: null,\n  length: 80,\n  coeff: 0.0002,\n  weight: 1\n});\n\nfunction makeSpring( spring ){\n  return assign( {}, defaults, spring );\n}\n\nfunction applySpring( spring ){\n  let body1 = spring.source,\n      body2 = spring.target,\n      length = spring.length < 0 ? defaults.length : spring.length,\n      dx = body2.pos.x - body1.pos.x,\n      dy = body2.pos.y - body1.pos.y,\n      r = Math.sqrt(dx * dx + dy * dy);\n\n  if (r === 0) {\n      dx = (Math.random() - 0.5) / 50;\n      dy = (Math.random() - 0.5) / 50;\n      r = Math.sqrt(dx * dx + dy * dy);\n  }\n\n  let d = r - length;\n  let coeff = ((!spring.coeff || spring.coeff < 0) ? defaults.springCoeff : spring.coeff) * d / r * spring.weight;\n\n  body1.force.x += coeff * dx;\n  body1.force.y += coeff * dy;\n\n  body2.force.x -= coeff * dx;\n  body2.force.y -= coeff * dy;\n}\n\nmodule.exports = { makeSpring, applySpring };\n\n\n\n// WEBPACK FOOTER //\n// ./src/euler/spring.js", "/**\nThe implementation of the Euler layout algorithm\n*/\n\nconst Layout = require('../layout');\nconst assign = require('../assign');\nconst defaults = require('./defaults');\nconst { tick } = require('./tick');\nconst { makeQuadtree } = require('./quadtree');\nconst { makeBody } = require('./body');\nconst { makeSpring } = require('./spring');\nconst isFn = fn => typeof fn === 'function';\nconst isParent = n => n.isParent();\nconst notIsParent = n => !isParent(n);\nconst isLocked = n => n.locked();\nconst notIsLocked = n => !isLocked(n);\nconst isParentEdge = e => isParent( e.source() ) || isParent( e.target() );\nconst notIsParentEdge = e => !isParentEdge(e);\nconst getBody = n => n.scratch('euler').body;\nconst getNonParentDescendants = n => isParent(n) ? n.descendants().filter( notIsParent ) : n;\n\nconst getScratch = el => {\n  let scratch = el.scratch('euler');\n\n  if( !scratch ){\n    scratch = {};\n\n    el.scratch('euler', scratch);\n  }\n\n  return scratch;\n};\n\nconst optFn = ( opt, ele ) => {\n  if( isFn( opt ) ){\n    return opt( ele );\n  } else {\n    return opt;\n  }\n};\n\nclass Euler extends Layout {\n  constructor( options ){\n    super( assign( {}, defaults, options ) );\n  }\n\n  prerun( state ){\n    let s = state;\n\n    s.quadtree = makeQuadtree();\n\n    let bodies = s.bodies = [];\n\n    // regular nodes\n    s.nodes.filter( n => notIsParent(n) ).forEach( n => {\n      let scratch = getScratch( n );\n\n      let body = makeBody({\n        pos: { x: scratch.x, y: scratch.y },\n        mass: optFn( s.mass, n ),\n        locked: scratch.locked\n      });\n\n      body._cyNode = n;\n\n      scratch.body = body;\n\n      body._scratch = scratch;\n\n      bodies.push( body );\n    } );\n\n    let springs = s.springs = [];\n\n    // regular edge springs\n    s.edges.filter( notIsParentEdge ).forEach( e => {\n      let spring = makeSpring({\n        source: getBody( e.source() ),\n        target: getBody( e.target() ),\n        length: optFn( s.springLength, e ),\n        coeff: optFn( s.springCoeff, e )\n      });\n\n      spring._cyEdge = e;\n\n      let scratch = getScratch( e );\n\n      spring._scratch = scratch;\n\n      scratch.spring = spring;\n\n      springs.push( spring );\n    } );\n\n    // compound edge springs\n    s.edges.filter( isParentEdge ).forEach( e => {\n      let sources = getNonParentDescendants( e.source() );\n      let targets = getNonParentDescendants( e.target() );\n\n      // just add one spring for perf\n      sources = [ sources[0] ];\n      targets = [ targets[0] ];\n\n      sources.forEach( src => {\n        targets.forEach( tgt => {\n          springs.push( makeSpring({\n            source: getBody( src ),\n            target: getBody( tgt ),\n            length: optFn( s.springLength, e ),\n            coeff: optFn( s.springCoeff, e )\n          }) );\n        } );\n      } );\n    } );\n  }\n\n  tick( state ){\n    let movement = tick( state );\n\n    let isDone = movement <= state.movementThreshold;\n\n    return isDone;\n  }\n}\n\nmodule.exports = Euler;\n\n\n\n// WEBPACK FOOTER //\n// ./src/euler/index.js", "const defaults = Object.freeze({\n  pos: { x: 0, y: 0 },\n  prevPos: { x: 0, y: 0 },\n  force: { x: 0, y: 0 },\n  velocity: { x: 0, y: 0 },\n  mass: 1\n});\n\nconst copyVec = v => ({ x: v.x, y: v.y });\nconst getValue = ( val, def ) => val != null ? val : def;\nconst getVec = ( vec, def ) => copyVec( getValue( vec, def ) );\n\nfunction makeBody( opts ){\n  let b = {};\n\n  b.pos = getVec( opts.pos, defaults.pos );\n  b.prevPos = getVec( opts.prevPos, b.pos );\n  b.force = getVec( opts.force, defaults.force );\n  b.velocity = getVec( opts.velocity, defaults.velocity );\n  b.mass = opts.mass != null ? opts.mass : defaults.mass;\n  b.locked = opts.locked;\n\n  return b;\n}\n\nmodule.exports = { makeBody };\n\n\n\n// WEBPACK FOOTER //\n// ./src/euler/body.js", "const defaults = Object.freeze({\n  // The ideal legth of a spring\n  // - This acts as a hint for the edge length\n  // - The edge length can be longer or shorter if the forces are set to extreme values\n  springLength: edge => 80,\n\n  // Hooke's law coefficient\n  // - The value ranges on [0, 1]\n  // - Lower values give looser springs\n  // - Higher values give tighter springs\n  springCoeff: edge => 0.0008,\n\n  // The mass of the node in the physics simulation\n  // - The mass affects the gravity node repulsion/attraction\n  mass: node => 4,\n\n  // Coulomb's law coefficient\n  // - Makes the nodes repel each other for negative values\n  // - Makes the nodes attract each other for positive values\n  gravity: -1.2,\n\n  // A force that pulls nodes towards the origin (0, 0)\n  // Higher values keep the components less spread out\n  pull: 0.001,\n\n  // Theta coefficient from Barnes-Hut simulation\n  // - Value ranges on [0, 1]\n  // - Performance is better with smaller values\n  // - Very small values may not create enough force to give a good result\n  theta: 0.666,\n\n  // Friction / drag coefficient to make the system stabilise over time\n  dragCoeff: 0.02,\n\n  // When the total of the squared position deltas is less than this value, the simulation ends\n  movementThreshold: 1,\n\n  // The amount of time passed per tick\n  // - Larger values result in faster runtimes but might spread things out too far\n  // - Smaller values produce more accurate results\n  timeStep: 20\n});\n\nmodule.exports = defaults;\n\n\n\n// WEBPACK FOOTER //\n// ./src/euler/defaults.js", "const defaultCoeff = 0.02;\n\nfunction applyDrag( body, manualDragCoeff ){\n  let dragCoeff;\n\n  if( manualDragCoeff != null ){\n    dragCoeff = manualDragCoeff;\n  } else if( body.dragCoeff != null ){\n    dragCoeff = body.dragCoeff;\n  } else {\n    dragCoeff = defaultCoeff;\n  }\n\n  body.force.x -= dragCoeff * body.velocity.x;\n  body.force.y -= dragCoeff * body.velocity.y;\n}\n\nmodule.exports = { applyDrag };\n\n\n\n// WEBPACK FOOTER //\n// ./src/euler/drag.js", "// use euler method for force integration http://en.wikipedia.org/wiki/Euler_method\n// return sum of squared position deltas\nfunction integrate( bodies, timeStep ){\n  var dx = 0, tx = 0,\n      dy = 0, ty = 0,\n      i,\n      max = bodies.length;\n\n  if (max === 0) {\n    return 0;\n  }\n\n  for (i = 0; i < max; ++i) {\n    var body = bodies[i],\n        coeff = timeStep / body.mass;\n\n    if( body.grabbed ){ continue; }\n\n    if( body.locked ){\n      body.velocity.x = 0;\n      body.velocity.y = 0;\n    } else {\n      body.velocity.x += coeff * body.force.x;\n      body.velocity.y += coeff * body.force.y;\n    }\n\n    var vx = body.velocity.x,\n        vy = body.velocity.y,\n        v = Math.sqrt(vx * vx + vy * vy);\n\n    if (v > 1) {\n      body.velocity.x = vx / v;\n      body.velocity.y = vy / v;\n    }\n\n    dx = timeStep * body.velocity.x;\n    dy = timeStep * body.velocity.y;\n\n    body.pos.x += dx;\n    body.pos.y += dy;\n\n    tx += Math.abs(dx); ty += Math.abs(dy);\n  }\n\n  return (tx * tx + ty * ty)/max;\n}\n\nmodule.exports = { integrate };\n\n\n\n// WEBPACK FOOTER //\n// ./src/euler/integrate.js", "// impl of barnes hut\n// http://www.eecs.berkeley.edu/~demmel/cs267/lecture26/lecture26.html\n// http://en.wikipedia.org/wiki/Barnes%E2%80%93Hut_simulation\n\nconst Node = require('./node');\nconst InsertStack = require('./insertStack');\n\nconst resetVec = v => { v.x = 0; v.y = 0; };\n\nconst isSamePosition = (p1, p2) => {\n  let threshold = 1e-8;\n  let dx = Math.abs(p1.x - p2.x);\n  let dy = Math.abs(p1.y - p2.y);\n\n  return dx < threshold && dy < threshold;\n};\n\nfunction makeQuadtree(){\n  let updateQueue = [],\n    insertStack = new InsertStack(),\n    nodesCache = [],\n    currentInCache = 0,\n    root = newNode();\n\n  function newNode() {\n    // To avoid pressure on GC we reuse nodes.\n    let node = nodesCache[currentInCache];\n    if (node) {\n      node.quad0 = null;\n      node.quad1 = null;\n      node.quad2 = null;\n      node.quad3 = null;\n      node.body = null;\n      node.mass = node.massX = node.massY = 0;\n      node.left = node.right = node.top = node.bottom = 0;\n    } else {\n      node = new Node();\n      nodesCache[currentInCache] = node;\n    }\n\n    ++currentInCache;\n    return node;\n  }\n\n  function update( sourceBody, gravity, theta, pull ) {\n    let queue = updateQueue,\n      v,\n      dx,\n      dy,\n      r, fx = 0,\n      fy = 0,\n      queueLength = 1,\n      shiftIdx = 0,\n      pushIdx = 1;\n\n    queue[0] = root;\n\n    resetVec( sourceBody.force );\n\n    let px = -sourceBody.pos.x;\n    let py = -sourceBody.pos.y;\n    let pr = Math.sqrt(px * px + py * py);\n    let pv = sourceBody.mass * pull / pr;\n\n    fx += pv * px;\n    fy += pv * py;\n\n    while (queueLength) {\n      let node = queue[shiftIdx],\n        body = node.body;\n\n      queueLength -= 1;\n      shiftIdx += 1;\n      let differentBody = (body !== sourceBody);\n      if (body && differentBody) {\n        // If the current node is a leaf node (and it is not source body),\n        // calculate the force exerted by the current node on body, and add this\n        // amount to body's net force.\n        dx = body.pos.x - sourceBody.pos.x;\n        dy = body.pos.y - sourceBody.pos.y;\n        r = Math.sqrt(dx * dx + dy * dy);\n\n        if (r === 0) {\n          // Poor man's protection against zero distance.\n          dx = (Math.random() - 0.5) / 50;\n          dy = (Math.random() - 0.5) / 50;\n          r = Math.sqrt(dx * dx + dy * dy);\n        }\n\n        // This is standard gravition force calculation but we divide\n        // by r^3 to save two operations when normalizing force vector.\n        v = gravity * body.mass * sourceBody.mass / (r * r * r);\n        fx += v * dx;\n        fy += v * dy;\n      } else if (differentBody) {\n        // Otherwise, calculate the ratio s / r,  where s is the width of the region\n        // represented by the internal node, and r is the distance between the body\n        // and the node's center-of-mass\n        dx = node.massX / node.mass - sourceBody.pos.x;\n        dy = node.massY / node.mass - sourceBody.pos.y;\n        r = Math.sqrt(dx * dx + dy * dy);\n\n        if (r === 0) {\n          // Sorry about code duplucation. I don't want to create many functions\n          // right away. Just want to see performance first.\n          dx = (Math.random() - 0.5) / 50;\n          dy = (Math.random() - 0.5) / 50;\n          r = Math.sqrt(dx * dx + dy * dy);\n        }\n        // If s / r < θ, treat this internal node as a single body, and calculate the\n        // force it exerts on sourceBody, and add this amount to sourceBody's net force.\n        if ((node.right - node.left) / r < theta) {\n          // in the if statement above we consider node's width only\n          // because the region was squarified during tree creation.\n          // Thus there is no difference between using width or height.\n          v = gravity * node.mass * sourceBody.mass / (r * r * r);\n          fx += v * dx;\n          fy += v * dy;\n        } else {\n          // Otherwise, run the procedure recursively on each of the current node's children.\n\n          // I intentionally unfolded this loop, to save several CPU cycles.\n          if (node.quad0) {\n            queue[pushIdx] = node.quad0;\n            queueLength += 1;\n            pushIdx += 1;\n          }\n          if (node.quad1) {\n            queue[pushIdx] = node.quad1;\n            queueLength += 1;\n            pushIdx += 1;\n          }\n          if (node.quad2) {\n            queue[pushIdx] = node.quad2;\n            queueLength += 1;\n            pushIdx += 1;\n          }\n          if (node.quad3) {\n            queue[pushIdx] = node.quad3;\n            queueLength += 1;\n            pushIdx += 1;\n          }\n        }\n      }\n    }\n\n    sourceBody.force.x += fx;\n    sourceBody.force.y += fy;\n  }\n\n  function insertBodies(bodies) {\n    if( bodies.length === 0 ){ return; }\n\n    let x1 = Number.MAX_VALUE,\n      y1 = Number.MAX_VALUE,\n      x2 = Number.MIN_VALUE,\n      y2 = Number.MIN_VALUE,\n      i,\n      max = bodies.length;\n\n    // To reduce quad tree depth we are looking for exact bounding box of all particles.\n    i = max;\n    while (i--) {\n      let x = bodies[i].pos.x;\n      let y = bodies[i].pos.y;\n      if (x < x1) {\n        x1 = x;\n      }\n      if (x > x2) {\n        x2 = x;\n      }\n      if (y < y1) {\n        y1 = y;\n      }\n      if (y > y2) {\n        y2 = y;\n      }\n    }\n\n    // Squarify the bounds.\n    let dx = x2 - x1,\n      dy = y2 - y1;\n    if (dx > dy) {\n      y2 = y1 + dx;\n    } else {\n      x2 = x1 + dy;\n    }\n\n    currentInCache = 0;\n    root = newNode();\n    root.left = x1;\n    root.right = x2;\n    root.top = y1;\n    root.bottom = y2;\n\n    i = max - 1;\n    if (i >= 0) {\n      root.body = bodies[i];\n    }\n    while (i--) {\n      insert(bodies[i], root);\n    }\n  }\n\n  function insert(newBody) {\n    insertStack.reset();\n    insertStack.push(root, newBody);\n\n    while (!insertStack.isEmpty()) {\n      let stackItem = insertStack.pop(),\n        node = stackItem.node,\n        body = stackItem.body;\n\n      if (!node.body) {\n        // This is internal node. Update the total mass of the node and center-of-mass.\n        let x = body.pos.x;\n        let y = body.pos.y;\n        node.mass = node.mass + body.mass;\n        node.massX = node.massX + body.mass * x;\n        node.massY = node.massY + body.mass * y;\n\n        // Recursively insert the body in the appropriate quadrant.\n        // But first find the appropriate quadrant.\n        let quadIdx = 0, // Assume we are in the 0's quad.\n          left = node.left,\n          right = (node.right + left) / 2,\n          top = node.top,\n          bottom = (node.bottom + top) / 2;\n\n        if (x > right) { // somewhere in the eastern part.\n          quadIdx = quadIdx + 1;\n          left = right;\n          right = node.right;\n        }\n        if (y > bottom) { // and in south.\n          quadIdx = quadIdx + 2;\n          top = bottom;\n          bottom = node.bottom;\n        }\n\n        let child = getChild(node, quadIdx);\n        if (!child) {\n          // The node is internal but this quadrant is not taken. Add\n          // subnode to it.\n          child = newNode();\n          child.left = left;\n          child.top = top;\n          child.right = right;\n          child.bottom = bottom;\n          child.body = body;\n\n          setChild(node, quadIdx, child);\n        } else {\n          // continue searching in this quadrant.\n          insertStack.push(child, body);\n        }\n      } else {\n        // We are trying to add to the leaf node.\n        // We have to convert current leaf into internal node\n        // and continue adding two nodes.\n        let oldBody = node.body;\n        node.body = null; // internal nodes do not cary bodies\n\n        if (isSamePosition(oldBody.pos, body.pos)) {\n          // Prevent infinite subdivision by bumping one node\n          // anywhere in this quadrant\n          let retriesCount = 3;\n          do {\n            let offset = Math.random();\n            let dx = (node.right - node.left) * offset;\n            let dy = (node.bottom - node.top) * offset;\n\n            oldBody.pos.x = node.left + dx;\n            oldBody.pos.y = node.top + dy;\n            retriesCount -= 1;\n            // Make sure we don't bump it out of the box. If we do, next iteration should fix it\n          } while (retriesCount > 0 && isSamePosition(oldBody.pos, body.pos));\n\n          if (retriesCount === 0 && isSamePosition(oldBody.pos, body.pos)) {\n            // This is very bad, we ran out of precision.\n            // if we do not return from the method we'll get into\n            // infinite loop here. So we sacrifice correctness of layout, and keep the app running\n            // Next layout iteration should get larger bounding box in the first step and fix this\n            return;\n          }\n        }\n        // Next iteration should subdivide node further.\n        insertStack.push(node, oldBody);\n        insertStack.push(node, body);\n      }\n    }\n  }\n\n  return {\n    insertBodies: insertBodies,\n    updateBodyForce: update\n  };\n}\n\nfunction getChild(node, idx) {\n  if (idx === 0) return node.quad0;\n  if (idx === 1) return node.quad1;\n  if (idx === 2) return node.quad2;\n  if (idx === 3) return node.quad3;\n  return null;\n}\n\nfunction setChild(node, idx, child) {\n  if (idx === 0) node.quad0 = child;\n  else if (idx === 1) node.quad1 = child;\n  else if (idx === 2) node.quad2 = child;\n  else if (idx === 3) node.quad3 = child;\n}\n\nmodule.exports = { makeQuadtree };\n\n\n\n// WEBPACK FOOTER //\n// ./src/euler/quadtree/index.js", "module.exports = InsertStack;\n\n/**\n * Our implmentation of QuadTree is non-recursive to avoid GC hit\n * This data structure represent stack of elements\n * which we are trying to insert into quad tree.\n */\nfunction InsertStack () {\n    this.stack = [];\n    this.popIdx = 0;\n}\n\nInsertStack.prototype = {\n    isEmpty: function() {\n        return this.popIdx === 0;\n    },\n    push: function (node, body) {\n        let item = this.stack[this.popIdx];\n        if (!item) {\n            // we are trying to avoid memory pressue: create new element\n            // only when absolutely necessary\n            this.stack[this.popIdx] = new InsertStackElement(node, body);\n        } else {\n            item.node = node;\n            item.body = body;\n        }\n        ++this.popIdx;\n    },\n    pop: function () {\n        if (this.popIdx > 0) {\n            return this.stack[--this.popIdx];\n        }\n    },\n    reset: function () {\n        this.popIdx = 0;\n    }\n};\n\nfunction InsertStackElement(node, body) {\n    this.node = node; // QuadTree node\n    this.body = body; // physical body which needs to be inserted to node\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/euler/quadtree/insertStack.js", "/**\n * Internal data structure to represent 2D QuadTree node\n */\nmodule.exports = function Node() {\n  // body stored inside this node. In quad tree only leaf nodes (by construction)\n  // contain boides:\n  this.body = null;\n\n  // Child nodes are stored in quads. Each quad is presented by number:\n  // 0 | 1\n  // -----\n  // 2 | 3\n  this.quad0 = null;\n  this.quad1 = null;\n  this.quad2 = null;\n  this.quad3 = null;\n\n  // Total mass of current node\n  this.mass = 0;\n\n  // Center of mass coordinates\n  this.massX = 0;\n  this.massY = 0;\n\n  // bounding box coordinates\n  this.left = 0;\n  this.top = 0;\n  this.bottom = 0;\n  this.right = 0;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/euler/quadtree/node.js", "const { integrate } = require('./integrate');\nconst { applyDrag } = require('./drag');\nconst { applySpring } = require('./spring');\n\nfunction tick({ bodies, springs, quadtree, timeStep, gravity, theta, dragCoeff, pull }){\n  // update body from scratch in case of any changes\n  bodies.forEach( body => {\n    let p = body._scratch;\n\n    if( !p ){ return; }\n\n    body.locked = p.locked;\n    body.grabbed = p.grabbed;\n    body.pos.x = p.x;\n    body.pos.y = p.y;\n  } );\n\n  quadtree.insertBodies( bodies );\n\n  for( let i = 0; i < bodies.length; i++ ){\n    let body = bodies[i];\n\n    quadtree.updateBodyForce( body, gravity, theta, pull );\n    applyDrag( body, dragCoeff );\n  }\n\n  for( let i = 0; i < springs.length; i++ ){\n    let spring = springs[i];\n\n    applySpring( spring );\n  }\n\n  let movement = integrate( bodies, timeStep );\n\n  // update scratch positions from body positions\n  bodies.forEach( body => {\n    let p = body._scratch;\n\n    if( !p ){ return; }\n\n    p.x = body.pos.x;\n    p.y = body.pos.y;\n  } );\n\n  return movement;\n}\n\nmodule.exports = { tick };\n\n\n\n// WEBPACK FOOTER //\n// ./src/euler/tick.js", "const Euler = require('./euler');\n\n// registers the extension on a cytoscape lib ref\nlet register = function( cytoscape ){\n  if( !cytoscape ){ return; } // can't register if cytoscape unspecified\n\n  cytoscape( 'layout', 'euler', Euler ); // register with cytoscape.js\n};\n\nif( typeof cytoscape !== 'undefined' ){ // expose to global cytoscape (i.e. window.cytoscape)\n  register( cytoscape );\n}\n\nmodule.exports = register;\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.js", "// general default options for force-directed layout\n\nmodule.exports = Object.freeze({\n  animate: true, // whether to show the layout as it's running; special 'end' value makes the layout animate like a discrete layout\n  refresh: 10, // number of ticks per frame; higher is faster but more jerky\n  maxIterations: 1000, // max iterations before the layout will bail out\n  maxSimulationTime: 4000, // max length in ms to run the layout\n  ungrabifyWhileSimulating: false, // so you can't drag nodes during layout\n  fit: true, // on every layout reposition of nodes, fit the viewport\n  padding: 30, // padding around the simulation\n  boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }\n\n  // layout event callbacks\n  ready: function(){}, // on layoutready\n  stop: function(){}, // on layoutstop\n\n  // positioning options\n  randomize: false, // use random node positions at beginning of layout\n  \n  // infinite layout options\n  infinite: false // overrides all other options for a forces-all-the-time mode\n});\n\n\n\n// WEBPACK FOOTER //\n// ./src/layout/defaults.js", "/**\nA generic continuous layout class\n*/\n\nconst assign = require('../assign');\nconst defaults = require('./defaults');\nconst makeBoundingBox = require('./make-bb');\nconst { setInitialPositionState, refreshPositions, getNodePositionData } = require('./position');\nconst { multitick } = require('./tick');\n\nclass Layout {\n  constructor( options ){\n    let o = this.options = assign( {}, defaults, options );\n\n\t\tlet nodes = o.eles.nodes();\n\t\t// prevent infinite loop and memory overflow when nodes occupy the same position\n\t\tif(!o.randomize)\n\t\t{\n\t\t\tnodes = nodes.sort((a,b)=>a.position().x-b.position().x);\n\t\t\tconst prev = {x: 0, y: 0};\n\t\t\tconst pos = {};\n\t\t\tnodes.forEach(n=>\n\t\t\t{\n\t\t\t\tObject.assign(pos,n.position());\n\t\t\t\tif(Math.abs(prev.x - pos.x) < o.theta && Math.abs(prev.y - pos.y) < o.theta)\n\t\t\t\t{\n\t\t\t\t\tn.position({x: Math.random()*100, y: Math.random()*100});\n\t\t\t\t}\n\t\t\t\tObject.assign(prev,pos);\n\t\t\t});\n\t\t}\n\n    let s = this.state = assign( {}, o, {\n      layout: this,\n      nodes,\n      edges: o.eles.edges(),\n      tickIndex: 0,\n      firstUpdate: true\n    } );\n\n    s.animateEnd = o.animate && o.animate === 'end';\n    s.animateContinuously = o.animate && !s.animateEnd;\n  }\n\n  run(){\n    let l = this;\n    let s = this.state;\n\n    s.tickIndex = 0;\n    s.firstUpdate = true;\n    s.startTime = Date.now();\n    s.running = true;\n\n    s.currentBoundingBox = makeBoundingBox( s.boundingBox, s.cy );\n\n    if( s.ready ){ l.one( 'ready', s.ready ); }\n    if( s.stop ){ l.one( 'stop', s.stop ); }\n\n    s.nodes.forEach( n => setInitialPositionState( n, s ) );\n\n    l.prerun( s );\n\n    if( s.animateContinuously ){\n      let ungrabify = node => {\n        if( !s.ungrabifyWhileSimulating ){ return; }\n\n        let grabbable = getNodePositionData( node, s ).grabbable = node.grabbable();\n\n        if( grabbable ){\n          node.ungrabify();\n        }\n      };\n\n      let regrabify = node => {\n        if( !s.ungrabifyWhileSimulating ){ return; }\n\n        let grabbable = getNodePositionData( node, s ).grabbable;\n\n        if( grabbable ){\n          node.grabify();\n        }\n      };\n\n      let updateGrabState = node => getNodePositionData( node, s ).grabbed = node.grabbed();\n\n      let onGrab = function({ target }){\n        updateGrabState( target );\n      };\n\n      let onFree = onGrab;\n\n      let onDrag = function({ target }){\n        let p = getNodePositionData( target, s );\n        let tp = target.position();\n\n        p.x = tp.x;\n        p.y = tp.y;\n      };\n\n      let listenToGrab = node => {\n        node.on('grab', onGrab);\n        node.on('free', onFree);\n        node.on('drag', onDrag);\n      };\n\n      let unlistenToGrab = node => {\n        node.removeListener('grab', onGrab);\n        node.removeListener('free', onFree);\n        node.removeListener('drag', onDrag);\n      };\n\n      let fit = () => {\n        if( s.fit && s.animateContinuously ){\n          s.cy.fit( s.padding );\n        }\n      };\n\n      let onNotDone = () => {\n        refreshPositions( s.nodes, s );\n        fit();\n\n        requestAnimationFrame( frame );\n      };\n\n      let frame = function(){\n        multitick( s, onNotDone, onDone );\n      };\n\n      let onDone = () => {\n        refreshPositions( s.nodes, s );\n        fit();\n\n        s.nodes.forEach( n => {\n          regrabify( n );\n          unlistenToGrab( n );\n        } );\n\n        s.running = false;\n\n        l.emit('layoutstop');\n      };\n\n      l.emit('layoutstart');\n\n      s.nodes.forEach( n => {\n        ungrabify( n );\n        listenToGrab( n );\n      } );\n\n      frame(); // kick off\n    } else {\n      let done = false;\n      let onNotDone = () => {};\n      let onDone = () => done = true;\n\n      while( !done ){\n        multitick( s, onNotDone, onDone );\n      }\n\n      s.eles.layoutPositions( this, s, node => {\n        let pd = getNodePositionData( node, s );\n\n        return { x: pd.x, y: pd.y };\n      } );\n    }\n\n    l.postrun( s );\n\n    return this; // chaining\n  }\n\n  prerun(){}\n  postrun(){}\n  tick(){}\n\n  stop(){\n    this.state.running = false;\n\n    return this; // chaining\n  }\n\n  destroy(){\n    return this; // chaining\n  }\n}\n\nmodule.exports = Layout;\n\n\n\n// WEBPACK FOOTER //\n// ./src/layout/index.js", "module.exports = function( bb, cy ){\n  if( bb == null ){\n    bb = { x1: 0, y1: 0, w: cy.width(), h: cy.height() };\n  } else { // copy\n    bb = { x1: bb.x1, x2: bb.x2, y1: bb.y1, y2: bb.y2, w: bb.w, h: bb.h };\n  }\n\n  if( bb.x2 == null ){ bb.x2 = bb.x1 + bb.w; }\n  if( bb.w == null ){ bb.w = bb.x2 - bb.x1; }\n  if( bb.y2 == null ){ bb.y2 = bb.y1 + bb.h; }\n  if( bb.h == null ){ bb.h = bb.y2 - bb.y1; }\n\n  return bb;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/layout/make-bb.js", "const assign = require('../assign');\n\nlet setInitialPositionState = function( node, state ){\n  let p = node.position();\n  let bb = state.currentBoundingBox;\n  let scratch = node.scratch( state.name );\n\n  if( scratch == null ){\n    scratch = {};\n\n    node.scratch( state.name, scratch );\n  }\n\n  assign( scratch, state.randomize ? {\n    x: bb.x1 + Math.random() * bb.w,\n    y: bb.y1 + Math.random() * bb.h\n  } : {\n    x: p.x,\n    y: p.y\n  } );\n\n  scratch.locked = node.locked();\n};\n\nlet getNodePositionData = function( node, state ){\n  return node.scratch( state.name );\n};\n\nlet refreshPositions = function( nodes, state ){\n  nodes.positions(function( node ){\n    let scratch = node.scratch( state.name );\n\n    return {\n      x: scratch.x,\n      y: scratch.y\n    };\n  });\n};\n\nmodule.exports = { setInitialPositionState, getNodePositionData, refreshPositions };\n\n\n\n// WEBPACK FOOTER //\n// ./src/layout/position.js", "const nop = function(){};\n\nlet tick = function( state ){\n  let s = state;\n  let l = state.layout;\n\n  let tickIndicatesDone = l.tick( s );\n\n  if( s.firstUpdate ){\n    if( s.animateContinuously ){ // indicate the initial positions have been set\n      s.layout.emit('layoutready');\n    }\n    s.firstUpdate = false;\n  }\n\n  s.tickIndex++;\n\n  let duration = Date.now() - s.startTime;\n\n  return !s.infinite && ( tickIndicatesDone || s.tickIndex >= s.maxIterations || duration >= s.maxSimulationTime );\n};\n\nlet multitick = function( state, onNotDone = nop, onDone = nop ){\n  let done = false;\n  let s = state;\n\n  for( let i = 0; i < s.refresh; i++ ){\n    done = !s.running || tick( s );\n\n    if( done ){ break; }\n  }\n\n  if( !done ){\n    onNotDone();\n  } else {\n    onDone();\n  }\n};\n\nmodule.exports = { tick, multitick };\n\n\n\n// WEBPACK FOOTER //\n// ./src/layout/tick.js"],
  "mappings": "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",
  "names": ["module", "exports", "Object", "assign", "bind", "tgt", "srcs", "forEach", "keys", "src", "k", "require", "defaults", "freeze", "source", "target", "length", "coeff", "weight", "makeSpring", "spring", "applySpring", "body1", "body2", "dx", "pos", "x", "dy", "y", "r", "Math", "sqrt", "random", "d", "springCoeff", "force", "Layout", "tick", "makeQuadtree", "makeBody", "isFn", "fn", "isParent", "n", "notIsParent", "isLocked", "locked", "notIsLocked", "isParentEdge", "e", "notIsParentEdge", "getBody", "scratch", "body", "getNonParentDescendants", "descendants", "filter", "getScratch", "el", "optFn", "opt", "ele", "Euler", "options", "state", "s", "quadtree", "bodies", "nodes", "mass", "_cyNode", "_scratch", "push", "springs", "edges", "springLength", "_cyEdge", "sources", "targets", "movement", "isDone", "movementThreshold", "prevPos", "velocity", "copyVec", "v", "getValue", "val", "def", "getVec", "vec", "opts", "b", "gravity", "pull", "theta", "dragCoeff", "timeStep", "defaultCoeff", "applyDrag", "manualDragCoeff", "integrate", "tx", "ty", "i", "max", "grabbed", "vx", "vy", "abs", "Node", "InsertStack", "resetVec", "isSamePosition", "p1", "p2", "threshold", "updateQueue", "insertStack", "nodesCache", "currentInCache", "root", "newNode", "node", "quad0", "quad1", "quad2", "quad3", "massX", "massY", "left", "right", "top", "bottom", "update", "sourceBody", "queue", "fx", "fy", "queueLength", "shiftIdx", "pushIdx", "px", "py", "pr", "pv", "differentBody", "insertBodies", "x1", "Number", "MAX_VALUE", "y1", "x2", "MIN_VALUE", "y2", "insert", "newBody", "reset", "isEmpty", "stackItem", "pop", "quadIdx", "child", "getChild", "setChild", "oldBody", "retriesCount", "offset", "updateBodyForce", "idx", "stack", "popIdx", "prototype", "item", "InsertStackElement", "p", "register", "cytoscape", "animate", "refresh", "maxIterations", "maxSimulationTime", "ungrabifyWhileSimulating", "fit", "padding", "boundingBox", "undefined", "ready", "stop", "randomize", "infinite", "makeBoundingBox", "setInitialPositionState", "refreshPositions", "getNodePositionData", "multitick", "o", "eles", "sort", "a", "position", "prev", "layout", "tickIndex", "firstUpdate", "animateEnd", "animateContinuously", "l", "startTime", "Date", "now", "running", "currentBoundingBox", "cy", "one", "prerun", "ungrabify", "grabbable", "regrabify", "grabify", "updateGrabState", "onGrab", "onFree", "onDrag", "tp", "listenToGrab", "on", "unlistenToGrab", "removeListener", "onNotDone", "requestAnimationFrame", "frame", "onDone", "emit", "done", "layoutPositions", "pd", "postrun", "bb", "w", "width", "h", "height", "name", "positions", "nop", "tickIndicatesDone", "duration"]
}
